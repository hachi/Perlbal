#!/usr/bin/perl -w
#
# Reverse-proxy load balancer w/ buffering, epoll, sendfile, etc
#
# (c) 1994, Brad Fitzpatrick, <brad@danga.com>


# Control flow at bottom (after class declarations
# and in particular, the @our declarations)

package Perlbal;

use constant DEBUG => 0;
use constant SHUTDOWN_BY_CLIENT => 1;  # silly profiling option

use strict;
use IO::Socket;
use IO::Handle;
use IO::SendFile;

use IO::File;
use Getopt::Long;
use Data::Dumper;
use BSD::Resource;
use Carp qw(cluck);

$SIG{'PIPE'} = "IGNORE";  # handled manually
$SIG{'INT'} = sub { print "Caught ^C, exiting.\n"; exit 0; };

use lib 'lib';
use Perlbal::Socket;
use Perlbal::TCPListener;
use Perlbal::HTTPHeaders;
use Perlbal::StatsListener;
use Perlbal::Service;
use Perlbal::ClientProxy;
use Perlbal::BackendHTTP;
use Perlbal::ClientManage;


######################################################################
# server management functions
######################################################################
package Perlbal;

our(%service);   # servicename -> Perlbal::Service
our($last_error);

sub error {
    $last_error = shift;
    return 0;
}

# returns 1 if command succeeded, 0 otherwise
sub run_manage_command {
    my ($cmd, $out) = @_;  # $out is output stream closure
    $cmd =~ s/\#.*//;
    $cmd =~ s/^\s+//;
    $cmd =~ s/\s+$//;
    $cmd = lc($cmd);
    $cmd =~ s/\s+/ /g;
    return 1 unless $cmd =~ /\S/;

    $out ||= sub {};

    my $err = sub {
	$out->("ERROR: $_[0]");
	return 0;
    };

    if (0) {
	my $rv = setrlimit(RLIMIT_NOFILE, 10_000, 10_000);
	print "setrlimit = $rv\n";
	
	my ($nowsoft, $nowhard)  = getrlimit(RLIMIT_NOFILE);
	print "getrlimit = ($nowsoft, $nowhard)\n";
    }

    if ($cmd =~ /^create service (\w+)$/) {
	my $name = $1;
	return $err->("service '$name' already exists") if $service{$name};
	$service{$name} = Perlbal::Service->new($name);
	return 1;
    }

    if ($cmd =~ /^show service$/) {
	foreach my $name (sort keys %service) {
	    my $svc = $service{$name};
	    $out->("$name $svc->{listen} " . ($svc->{enabled} ? "ENABLED" : "DISABLED"));
	}
	return 1;
    }

    if ($cmd =~ /^set (\w+)\.([\w\.]+) ?= ?(.+)$/) {
	my ($name, $key, $val) = ($1, $2, $3);
	my $svc = $service{$name};
	return $err->("service '$name' does not exist") unless $svc;
	return $svc->set($key, $val, $out);
    }

    if ($cmd =~ /^(disable|enable) (\w+)$/) {
        my ($verb, $name) = ($1, $2);
        my $svc = $service{$name};
        return $err->("service '$name' does not exist") unless $svc;
        return $svc->$verb($out);
    }

    return $err->("unknown command: $cmd");
}

sub load_config {
    my ($file, $writer) = @_;
    open (F, $file) or die "Error opening config file ($file): $!\n";
    while (<F>) {
	return 0 unless run_manage_command($_, $writer);
    }
    close(F);
    return 1;
}




my $opt_daemonize;
my $opt_manage;
my $opt_config;
exit 1 unless
    Getopt::Long::GetOptions(
	       'daemon' => \$opt_daemonize,
	       'config=s' => \$opt_config,
	       'manage=s' => \$opt_manage,
	       );

my $default_config = "/etc/perlbal/perlbal.conf";
$opt_config = $default_config if ! $opt_config && -e $default_config;

# load user config
load_config($opt_config, sub { print STDOUT "$_[0]\n"; }) if $opt_config;

unless (Perlbal::Socket::watched_sockets() > 0) {
    die "No services or management port configured.  Nothing to do.  Stopping.\n";
}

print "Ready.\n";

# wait for activity
Perlbal::Socket->wait_loop();




1;
