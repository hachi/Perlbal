#!/usr/bin/perl -w
#
# Reverse-proxy load balancer w/ buffering, epoll, sendfile, etc
#
# (c) 1994, Brad Fitzpatrick, <brad@danga.com>

package Perlbal;

use constant DEBUG => 0;
use constant DEBUG_OBJ => 1;

use strict;
use IO::Socket;
use IO::Handle;
use IO::SendFile;
use IO::File;

use Linux::AIO;

use Getopt::Long;
use BSD::Resource;
use Carp qw(cluck croak);
use POSIX ();

use lib 'lib';

use Perlbal::HTTPHeaders;
use Perlbal::Service;
use Perlbal::Socket;
use Perlbal::TCPListener;
use Perlbal::StatsListener;
use Perlbal::ClientManage;
use Perlbal::ClientHTTPBase;
use Perlbal::ClientProxy;
use Perlbal::ClientHTTP;
use Perlbal::BackendHTTP;

$SIG{'PIPE'} = "IGNORE";  # handled manually

our(%service);   # servicename -> Perlbal::Service
our($last_error);

sub error {
    $last_error = shift;
    return 0;
}

# Object instance counts, for debugging and leak detection
our(%ObjCount);  # classname -> instances
our(%ObjTotal);  # classname -> instances
sub objctor {
    if (DEBUG_OBJ) {
        my $caller = (caller)[0];
        $caller .= "-$_[0]" if $_[0];
        $ObjCount{$caller}++;
        $ObjTotal{$caller}++;
    }
}
sub objdtor {
    if (DEBUG_OBJ) {
        my $caller = (caller)[0];
        $caller .= "-$_[0]" if $_[0];
        $ObjCount{$caller}--;
    }
}

sub service_names {
    return sort keys %service;
}

sub service {
    my $class = shift;
    return $service{$_[0]};
}

# returns 1 if command succeeded, 0 otherwise
sub run_manage_command {
    my ($cmd, $out) = @_;  # $out is output stream closure
    $cmd =~ s/\#.*//;
    $cmd =~ s/^\s+//;
    $cmd =~ s/\s+$//;
    $cmd = lc($cmd);
    $cmd =~ s/\s+/ /g;
    return 1 unless $cmd =~ /\S/;

    $out ||= sub {};

    my $err = sub {
        $out->("ERROR: $_[0]");
        return 0;
    };

    if ($cmd =~ /^obj$/) {
        foreach (sort keys %ObjCount) {
            $out->("$_ = $ObjCount{$_} (tot=$ObjTotal{$_})");
        }
        return 1;
    }

    exit(0) if $cmd eq "shutdown";

    if ($cmd eq 'shutdown graceful') {
        # tell all sockets we're doing a graceful stop
        my $sf = Perlbal::Socket->get_sock_ref;
        foreach my $k (keys %$sf) {
            my Perlbal::Socket $v = $sf->{$k};
            $v->die_gracefully();
        }
        
        # register a post loop callback that will end the event loop when we only have
        # a single socket left, the AIO socket
        Perlbal::Socket->SetPostLoopCallback(sub {
            my ($descmap, $otherfds) = @_;

            # simple; if we have more than one descriptor left in %$descmap, we're not done yet
            return (scalar(keys %$descmap) > 1) ? 1 : 0;
        });
        return 1;
    }

    if ($cmd =~ /^socks(?: (\w+))?$/) {
        my $mode = $1 || "all";
        my $sf = Perlbal::Socket->get_sock_ref;

        if ($mode eq "summary") {
            my %count;
            my $write_buf = 0;
            my $open_files = 0;
            while (my $k = each %$sf) {
                my Perlbal::Socket $v = $sf->{$k};
                $count{ref $v}++;
                $write_buf += $v->{write_buf_size};
                if ($v->isa("Perlbal::ClientHTTPBase")) {
                    my Perlbal::ClientHTTPBase $cv = $v;
                    $open_files++ if $cv->{'reproxy_fd'};
                }
            }

            foreach (sort keys %count) {
                $out->(sprintf("%5d $_", $count{$_}));
            }
            $out->();
            $out->(sprintf("Aggregate write buffer: %.1fk", $write_buf / 1024));
            $out->(sprintf("            Open files: %d", $open_files));

        } elsif ($mode eq "all") {

            my $now = time;
            $out->(sprintf("%5s %6s", "fd", "age"));
            foreach (sort { $a <=> $b } keys %$sf) {
                my $sock = $sf->{$_};
                my $age = $now - $sock->{create_time};
                $out->(sprintf("%5d %5ds %s", $_, $age, $sock->as_string));
            }
        }
        return 1;
    }

    if ($cmd =~ /^show service (\w+)$/) {
        my $sname = $1;
        my Perlbal::Service $svc = $service{$sname};
        return $err->("Unknown service") unless $sname;
        $svc->stats_info($out);
        return 1;
    }

    if ($cmd =~ /^server (\w+) ?= ?(.+)$/) {
        my ($key, $val) = ($1, $2);
        return $err->("Expected numeric parameter") unless $val =~ /^\d+$/;

        if ($key eq "max_connections") {
            my ($nowsoft, $nowhard)  = getrlimit(RLIMIT_NOFILE);
            $out->("WAS: ($nowsoft, $nowhard)");

            unless ($> == 0) {
                $out->("ERROR: need to be root to increase max connections");
            }
        } elsif ($key eq "aio_threads") {

        }

        #my $rv = setrlimit(RLIMIT_NOFILE, 10_000, 10_000);
        #print "setrlimit = $rv\n";
        return 1;
    }

    if ($cmd =~ /^create service (\w+)$/) {
        my $name = $1;
        return $err->("service '$name' already exists") if $service{$name};
        $service{$name} = Perlbal::Service->new($name);
        return 1;
    }

    if ($cmd =~ /^show service$/) {
        foreach my $name (sort keys %service) {
            my $svc = $service{$name};
            $out->("$name $svc->{listen} " . ($svc->{enabled} ? "ENABLED" : "DISABLED"));
        }
        return 1;
    }

    if ($cmd =~ /^set (\w+)\.([\w\.]+) ?= ?(.+)$/) {
        my ($name, $key, $val) = ($1, $2, $3);
        my $svc = $service{$name};
        return $err->("service '$name' does not exist") unless $svc;
        return $svc->set($key, $val, $out);
    }

    if ($cmd =~ /^(disable|enable) (\w+)$/) {
        my ($verb, $name) = ($1, $2);
        my $svc = $service{$name};
        return $err->("service '$name' does not exist") unless $svc;
        return $svc->$verb($out);
    }

    return $err->("unknown command: $cmd");
}

sub load_config {
    my ($file, $writer) = @_;
    open (F, $file) or die "Error opening config file ($file): $!\n";
    while (<F>) {
        return 0 unless run_manage_command($_, $writer);
    }
    close(F);
    return 1;
}

sub daemonize {
    my($pid, $sess_id, $i);

    ## Fork and exit parent
    if ($pid = fork) { exit 0; }

    ## Detach ourselves from the terminal
    croak "Cannot detach from controlling terminal"
        unless $sess_id = POSIX::setsid();

    ## Prevent possibility of acquiring a controling terminal
    $SIG{'HUP'} = 'IGNORE';
    if ($pid = fork) { exit 0; }

    ## Change working directory
    chdir "/";

    ## Clear file creation mask
    umask 0;

    ## Close open file descriptors
    close(STDIN);
    close(STDOUT);
    close(STDERR);

    ## Reopen stderr, stdout, stdin to /dev/null
    open(STDIN,  "+>/dev/null");
    open(STDOUT, "+>&STDIN");
    open(STDERR, "+>&STDIN");
}

my $opt_daemonize;
my $opt_manage;
my $opt_config;
exit 1 unless
    Getopt::Long::GetOptions(
               'daemon' => \$opt_daemonize,
               'config=s' => \$opt_config,
               'manage=s' => \$opt_manage,
               );

my $default_config = "/etc/perlbal/perlbal.conf";
$opt_config = $default_config if ! $opt_config && -e $default_config;

# load user config
load_config($opt_config, sub { print STDOUT "$_[0]\n"; }) if $opt_config;

unless (Perlbal::Socket->WatchedSockets() > 0) {
    die "No services or management port configured.  Nothing to do.  Stopping.\n";
}

if ($opt_daemonize) {
    # required before fork: (as of Linux::AIO 1.1, but may change)
    Linux::AIO::max_parallel(0);
    daemonize();
} else {
    print "Running.\n";
}

# number of AIO threads.  the number of outstanding requests isn't
# affected by this
Linux::AIO::min_parallel(3);

# register Linux::AIO's pipe which gets written to from threads
# doing blocking IO
my $aio_fd = Linux::AIO::poll_fileno;

Perlbal::Socket->OtherFds(
    $aio_fd => sub {
        # run any callbacks on async file IO operations
        Linux::AIO::poll_cb();
    },
);



# wait for activity
Perlbal::Socket->EventLoop();


1;


# Local Variables:
# mode: perl
# c-basic-indent: 4
# indent-tabs-mode: nil
# End:
